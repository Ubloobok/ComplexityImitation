# Имитация Сложности — Антиномия Простого и Сложного

Простое не требует Сложности.

Программисты много говорят про сложность решений. Мы можем часами размышлять о правильных шаблонах, красивых абстракциях и цепочках зависимостей. Однако давайте поговорим открыто, всегда ли сложность обусловлена решаемой проблемой? Не оказываемся ли мы в плену наших стереотипов и убеждений?

![8](Slides/Slide(8).PNG)

<cut />

День добрый. Меня зовут Никита Данилов, я ведущий .NET разработчик. В 2018 году я выступал на встрече [SarDotNet](https://vk.com/sardotnet) с [докладом "Имитация сложности"](https://www.youtube.com/watch?v=z6yxXJxmst8) (Саратовское сообщество всероссийского [DotNetRu](https://vk.com/dotnetru)), вольной расшифровкой которого хочу поделиться.

***О себе***

Начинал как WPF .NET разработчик, сейчас заядлый Back-end разработчик, веб-сервисы, базы данных, очереди, микросервисы и всё такое. Интересуюсь как техническими нюансами .NET платформы, так и философскими аспектами ремесла программиста. На момент выступления заканчивал аспирантуру (в 2019 году закончил) и четвёртый год преподавал в вузе, что вызвало у меня определенную ментальную и профессиональную деформацию.

## Вступление

Сегодня мы поговорим об имитации. Вынужден предупредить заранее, всё что вы сейчас увидите и услышите – мысли на обдумывание, а не точные советы.

## Сложное

Программисты много говорят про сложность решений. Мы можем часами размышлять о правильных шаблонах и красивых абстракциях. Как сделать еще гибче, еще круче, еще сложнее. Как усложнить. Обычно мы двигаемся от простого к сложному.

![3](Slides/Slide(3)Crop.png)

> Простое → **Сложное**

На доклад меня сподвигло именно то, что мы мало говорим о простом. По крайней мере в моём окружении мало разговоров об этом. Существуют статьи восхваляющие простые решения, но таковых довольно мало и чаще мы говорим о сложном. Давайте сегодня пройдемся от сложного к простому, через таинственную имитацию сложности. Предлагаю всем вместе подумать, почему мы так мало говорим про простые решения и много концентрируемся на сложных.

![4](Slides/Slide(4)Crop.png)

> Простое ← Имитация Сложности ← **Сложное**

### Малое и Большое, Простое и ... Хаос

Если говорить про сложное и сложность, то вроде много всего написано. Размышляя про код, модули или архитектуру, мы интуитивно понимаем что такое маленькое и большое. Можем примерно отличить нечто простое (как кирпич) и условно понимаем когда творится некий хаос (с лапшой). Если присмотреться, все эти термины тесно связаны с понятием сложности.

![5](Slides/Slide(5)Crop.png)

**Вопрос:** Попробуйте подумать, повспоминать и ответить на следующие вопросы:

- Что такое сложность?
- Какие вообще существуют критерии и определения сложности кода или архтитектуры?
- Какие критерии кода или архитектуры означают сложность именно для вас?

![6](Slides/Slide(6)Crop.png)

Обозначений сложности много, она многогранна, перечислим лишь наиболее известные:

- Метрики размера программ:
  - SLOC (Source Lines of Code), анализ количества строк кода;
  - Метрика Холстеда, анализ числа операторов и операндов программы;
- Метрики сложности потока управления:
  - Метрика Маккейба, или Цикломатическая сложность (англ. Cyclomatic);
  - Метрика Майерса (расширение метрики Маккейба);
  - Метрика Джилба, насыщенность выражениями типа IF-THEN-ELSE;
- Метрики сложности потока данных:
  - Метрика Чепина и её модификации;
  - Метрика Спена;
- Метрики специфичные для объектно-ориентированного программирования:
  - NOC (Number of Children), анализ количества непосредственных потомков;
  - DIT (Depth of Inheritance), анализ глубины дерева наследования;
  - WMC (Weighted Methods per Class), анализ суммарной сложности всех методов класса;
  - CBO (Coupling Between Classes);
  - LCOM (Lack of Cohesion of Methods);
- и т.д. и многие другие.

К сожалению, зачастую люди находят информацию лишь про SLOC, где обнаруживают критику, что метрика устарела с развитием языков, и на этом изучение теории сложности программного обеспечения завершается. Различные метрики сложности программного обеспечения мы постараемся разобрать в следующей статье (надеюсь). Сейчас же не будем отвлекаться, запомним лишь факт их существования.

Словари определяют, что само слово «сложный» является антонимом к слову «простой» и имеет несколько устоявшихся значений:

- состоящий из нескольких частей, элементов;
- многообразный по составу входящих частей, отношений, связей;
- затейливый, замысловатый по строению, форме;
- представляющий затруднения для понимания, решения, осуществления и т.п.

Если так посмотреть, наш мир и правда много в чем сложен. Как нам думается.

![8](Slides/Slide(8).PNG)

Выписал навскидку слова, которые крутились в голове – ГОСТ, финансы, LESS, физика, Docker и т.д.
С одной стороны, мы зачастую сами явно не упрощаем. Например, [вспомним](https://dzone.com/articles/git-branching-structural-strategy) какие шаблоны работы с Git люди умудряются придумать.
С другой, далеко не всё является сложным. Известны случаи когда один небольшой VBA скрипт в Excel решал проблемы аналитики целого завода. Завод вряд ли можно назвать простым, это огромная сложная структура.
Собирается бригада аналитиков, менеджеров, приносятся фреймворки, Blue-Green развертывание. И вот вы уже сидите с 40 серверами и пытаетесь понять почему оно не работает. Решая примерно то же, что решал VBA скрипт.

## Имитация Сложности

Несмотря на то, что в этом мире существуют явно сложные задачи, тем не менее есть особая категория решений, которые строятся сложнее чем они могли бы быть построены (например, пишется больше кода чем необходимо для решения проблемы). Именно где то здесь кроется имитация, можно сказать промежуточная большая серая зона.

![9](Slides/Slide(9)Crop.png)

Разрабатываемое решение попавшее в эту зону уже нельзя считать простым, однако и сложность пока выглядит сомнительно либо неуместно.

На мой взгляд, для описания подобной ситуации подходит слово «имитация» имеющее древние корни:

- imitari (праиндоевр.) — подражать, воспроизводить.
- imitatio (лат.) — подражание.

Когда мы имитируем сложность, у нас её еще нет, но мы решили попробовать ей подражать. Позвольте объяснить точнее, рассмотрим на условном примере.

Вам передают приложение, разработанное кем то иным, допустим REST API .
Вы открываете и видите 7 проектов: контракты, ядро, данные, веб-часть, фасады.
Богато выглядит, думаете вы, наверняка оно решает нечто важное.

![11](Slides/Slide(11)Crop.png)

Открываете первый проект. Там 2 директории. 2 интерфейса на фасады. Некий интерфейс видимо указывающий на возможность валидации сущности. Хотя сущностей всего 2 и вроде и логично, что их можно валидировать.

Открываете фасады, думаете может там хитрость закопана. Там обнарижуется всего два фасада, по одной реализации, без переключения с одной базы данных на другую или тому подобного. Закрадываются сомнения, а всё ли так богато на самом деле.

Постепенно вы добираетесь до проекта Web, думается там вся соль! Ан нет, там только один контроллер и стандартная конфигурация.

![15](Slides/Slide(15)Crop.png)

Пример несколько гипербализирован, однако ситуация многим может быть знакома.

**Вопрос:** На ваш взгляд, обоснована ли здесь такая организация кода, архитектуры, проектов?

Универсальный ответ - "зависит", ведь это зависит от контекста, от поставленной задачи и чего хотели достичь.
Возможно это всё будет ещё расширяться, возможно нет, но если вдруг будет, приложение готово к расширению.
Разумеется, я выступаю за продуманную организации кода, а с другой стороны, вроде всё это упаковывается в 2 проекта и несколько файлов, на первое время.

Рассмотрим другой пример.

Вы создаете новое приложение, допустим, REST API. Решив начать всё с контроллера, вы описали контроллер, описали сущности контракта.

![16](Slides/Slide(16)Crop.png)

И ощущаете, вроде маловато. Надо еще ведь модульные тесты написать - создаете аксессор (и/или: репозиторий, UnitOfWork, DB-контекст, ...).

![17](Slides/Slide(17)Crop.png)

Потом идете на кухню попить чайку, открываете книгу про шаблоны проектирования, посещаете конференцию где вам рассказывают еще 3 истории успеха внедрения DDD и CQRS, т.е. вы где-то что-то зачем-то узнаете. Не успеваете оглянуться, вжух – кембрийский взрыв. В приложении появляются останки всех известных слов для выражения зависимостей:

![18](Slides/Slide(18)Crop.png)

Контракты, фасады, прокси, процессоры и т.д. и т.п.
Я знаком с приложениями где больше слов, а делают они пока очень мало чего.

> Справедливости ради, спустя 2 года эти приложения научились делать значительно больше и превратились в серьезные системы. Правда, некоторые зависимости так никогда и не были использованы, а некоторые раздробились на множество новых.

**Вопрос**: Насколько оно обосновано?

Опять таки, возможно, всё здесь и как надо, возможно усложнили код предполагая будущие задачи.
В теории правильно выстроенная архитектура и не должна позволять сделать неправильно.
Всё зависит от контекста и наших целей.
Однако, надеюсь я сумел донести саму идею существования определенной грани, когда реализумая сложность еще не нужна, где начинается имитация сложности - будущей или *вымышленной*.

![19](Slides/Slide(19)Crop.png)

Имитация сложности – подражание сложности.

Попробуйте подумать, зачем мы имитируем?

* Крутизна, хотим чтобы выглядело круто, посложнее, солиднее, богаче, изучить новый подход.
* Изучение, пробуем сделать посложнее дабы изучить новый подсмотренный подход.
* Демонстрация, показать что мы это умеем.
* Вдохновение, попробовать нечто новое и крышесносящее, подслушанное на конференции.
* Опасения, желаем чтобы приняли диплом.
* Предусмотрельность, стараемся добиться слабой связанности модулей для последующих изменений.
* Гибкость, волшебное слово "гибкость", чтобы было гибко, конфигурируемо, мы же сейчас всё сделаем так, что потом поменяем два контракта и всё будет работать как раньше.
* Поддерживаемость, стараемся избежать технического долга.

Причины могут быть разные, я не берусь сейчас разделять на хорошие и плохие. Главное предлагаю принять, что есть ситуации, когда мы имитируем. Например, мне знакомы ситуации, когда люди привносили сложность т.к. им было стыдно показать простое решение. Они выходили на кухню, там все рассказывали про сложные шаблоны и рождалась мысль: "Как же я свои 2 класса покажу, это же всё не по книгам".

Причин усложнить всегда много, но зачастую мы их не различаем. Важно **рационально** и **честно** оценивать зачем мы усложняем. Ибо зачастую какая главная причина? Сделаем погибче, еще гибче, на будущее. Многое прячем под этими общими словами.

Мне доводилось самому делать такие приложения как показал на предыдущих слайдах – сразу всё по полочкам, с кучей слов. Потом вернулся через 3 года и выкинул много лишнего, что так и не пригодилось.

Серая область имитации сложности довольно большая и относительная.
Но чтобы её лучше понять, почему она есть – надо сначала поговорить про простое и сравнить потом с простым.

## Простое

Если существуют сложность и критерии сложности, то с другой стороны будет нечто обратное, т.е. простое. Мы часто забываем о преимуществах которые нам может дать простое решение.

![21](Slides/Slide(21)Crop.png)

> **Простое** ← Имитация Сложности ← Сложное

Довольно давно сформулирован принцип [KISS](http://principles-wiki.net/principles:keep_it_simple_stupid) (Keep it Simple S.), про него достаточно много всего написано и рассказано. Вспомним, что нам в принципе дает простое решение?

![22](Slides/Slide(22)Crop.png)

### 1. Проще → Быстрее Разработка

Во-первых, простое решение быстрее реализовать. Уточню, реализовать *изначально*, тему дальнейшей поддержки/развития мы лишь отчасти затронем чуть ниже.

Безусловно, выбор решения во многом зависит от решаемой проблемы и поставленной задачи.
Сани, машина, ракета - всё из этого позволяет добраться из пункта А в пункт Б.

![23](Slides/Slide(23)Crop.png)

Сани не сгодятся для полета в космос, зато их сделать быстрее чем космический корабль.
Если мы понимаем, что нам надо лишь съехать с горки, то быть может и куска линолеума хватит, а в этом случае даже сани будут являться имитацией сложности. Мы захотели на более вычурных санках съехать, хотя линолеум прекрасно справился бы, а могли сэкономить деньги и время.

Другой пример это когда вам необходимо доплыть до пункта Б.

![24](Slides/Slide(24)Crop.png)

Летом, чтобы доплыть до островка неподалеку, вы не всегда строите себе личный катер, иногда хватает подручных средств.
Иногда вы арендуете уже существующий катер, сложность при этом перекладывается.

## 2. Проще → Надежнее Работа

Во-вторых, простое решение обеспечивает более надежную работу.
Это заявление может выглядеть более спорным, а потому позвольте объяснить подробнее.
Обратим наше внимание на названные ранее метрики сложности.
Значение любой из них так или иначе прямо пропорционально числу "подвижных" частей нашего решения. Если мы входим в зону имитации сложности, мы начинаем добавлять код, вряд ли убавлять.

**Вопрос**: Какова вероятность ошибки или опечатки в строке кода? 1% или 0.1% или 0.01%?

Отчасти понадеемся на компилятор, он сможет обнаружить самые очевидные ошибки .
Допустим мы уверены, что вероятность ошибки в строке кода крайне мала, пусть 0.01%.
Перемножив вероятности ошибки на большом приложении с 10 000 строк кода, получаем 100%, что там есть ошибка. Что-то здесь не так...

![26](Slides/Slide(26)Crop.png)

Причем, исправление одной ошибки уменьшит вероятность следующей лишь незначительно, ведь эти событий являются совсем либо практически независимыми.
Допустим мы пишем код идеально.
Уменьшим вероятность еще на 2 знака, получим вероятность ошибки 1% на 10 000 строк кода.
А потом вспоминаем, что у нас минимум 100 взаимосвязей или разных зависимостей между классами...

![27](Slides/Slide(27)Crop.png)

Продолжать можно бесконечно.
"Больше последовательных звеньев - ниже надежность".
Сложность проверки превосходит количество строк кода в миллионы раз.
Поэтому, чем меньше кода в вашем решении, тем больше шанс что он будет работать надежно. Обычно.

## 3. Проще → Понятнее для Поддержки

В-третьих, простое решение понятнее для поддержки.
Снова обратим наше внимание на метрики сложности, многие из которых означают – чем сложнее, тем больше у вас будет методов, классов, абстракций. Всевозможные шаблоны придуманы чтобы сокрыть сложность за неким интерфейсом. Даже если они звучат лаконично, в реализации это может означать десятки классов, т.е. есть сложность зачастую привносит новые абстракции.

Абстракции это великолепный инструмент доступный человеческому разуму. Абстракции упрощают восприятие при моделировании, позволяют сокрыть сложность и абстрагироваться от деталей.
Здесь мы спрятали за фасадом, здесь укрыли в репозиторий, и кажется что сложности у нас нет.

Если мы начинаем вводить абстракции заранее (а это почти всегда так), то что мы делаем? Имитируем будущую сложность.

![18](Slides/Slide(18)Crop.png)

Проходит время и вы оказываетесь в роли знаменитой Даши. Где-то в глубине приложения что-то упало и вы начинаете копать.

![30](Slides/Slide(30)Crop.PNG)

Начинаем смотреть на наши зависимости приправленные любимым контейнером для внедрения.
Что-то там делается, вызывается менеджер с разными параметрами.

    class Controller
    {
        Controller(IManager, ILogger, ISettings) { … }
    
        Load()
        {
            …
            var data = _manager.Load(...);
            …
        }
    }

Идем дальше. Менеджер вроде тоже вполне прозрачный, зависимости какие-то, но параметры перекомпоновывает, поэтому надо разобраться как именно. Разобрались, идём дальше.

    class Manager
    {
        Manager(IFacade, ILogger, IChecker, IWrapper) { … }
    
        Load()
        {
            …
            var data = _facade.Load(...);
            …
        }
    }

Открываем фасад, там еще порция зависимостей. Перегруппировка параметров и вызов дальше аксессора.

    class Facade
    {
        Facade(IAccessor, ILogger, IPermission, IPhone) { … }
    
        Load()
        {
            …
            var data = _accessor.Load(...);
            …
        }
    }

Открываем аксессор, нет зависимостей – ура! Подождите ка...

    class Accessor
    {
        Accessor() { }
    
        Load(...)
        {
            NLog.Instance.Write(…);
            var context = new DbContext("connectionString");
            var data = context.Entities.ToList();
        }
    }

Видимо человек, кто писал аксессор на этом уровне, уже просто устал разбираться.
Взял любимый логгер, указал хардкодом строку подключения для начала разработки, да так и оставил.
Теоретически, архитектура не должна позволять делать такое.
Только кто запретит человеку выстрелить себе в ногу?
Возможно на код-ревью потом отловим. А может и нет, переименуется строка подключения и всё полетит.

Этот пример о том, что вот лично я стал уставать от обилия абстракций.
Здесь десяток абстракций запомни, здесь десяток, и вроде недолго разбираться, но время тратится.
Грустно, хочется проблему решать, а не заучивать плоды чьей то фантазии.

### Так почему не делать всё Просто?

Итого, простота ведет к Скорости (уменьшению затрачиваемого времени), к Надежности, к Поддерживаемости. Казалось бы,

_"Обалдеть, дайте две!_" (с)

Замечательно, давайте делать всё максимально просто, чего я вообще тут про имитацию распинаюсь.

![36](Slides/Slide(36)Crop.png)

Разумеется указанные параметры здесь встают в позу знаменитой тройки: лебедь, рак и щука.

![37](Slides/Slide(37).PNG)

([источник](http://audiohrestomatiya.ru/competitions2/?page=219&now_sort=name_d&now_filter_name=name&now_filter_val=), автор: Анна Тимакова, Город: Москва, возраст: 7 лет)

К сожалению, реально полноценно совместить лишь 2 аспекта, а 3й обязательно будет страдать.
Примерно как CAP теорема, или Тройственная ограниченность проекта, только про другое (очень уж людям нравится треугольники).
Нам придется делать выбор, а выбор обусловлен целью и задачами, как мы помним.
Решаемая задача каждый раз особая, где для одной допустимо простое решение, для другой придется усложнять.
В одном случае топорное решение даст проблемы при поддержке, а в другом наоборот позволит быстрее переписать при необходимости.

## Кто виноват? Что делать?

К чему я это всё. Про что предлагаю подумать. 

Я не призываю совсем избегать сложности, ведь она бывает оправдана, да и зачастую она оправдана.
Всё-таки мы тут проблемы Бизнеса решаем, а не просто лямбды пишем.
Только вот если мы всегда будем строить лишь космические корабли, то саночек у нас не останется.

Прежде всего я призываю быть честными по отношению к себе, к коллегам и решаемой задаче.

Старайтесь начинать всегда с упрощения самой постановки проблемы, до начала обдумывания и проектирования.
Возможно, проблема решается большими красными буквами на странице, вместо отката распределенной транзакции.

> "Всё следует упрощать до тех пор, пока это возможно, но не более того" (с) Альберт Эйнштейн

И только тогда, при реализации решение – вы получите возможность сами решить, желаете ли вы привнести сложность.
Если вы знаете что нужен восхитительно гибкий механизм – прекрасно, вы эксперт, делайте.
Если вы хотите именно здесь опробовать новый подход, и знаете что он не заставит никого страдать – замечательно, пробуйте.

Только помните о том, что вам дает простое решение.
Вообще давайте чаще задумываться о простом, глядишь тогда и лучше станем понимать когда стоит привносить сложность.
Не оправдывая всё словом «гибкость».
Потом вам и другие скажут спасибо, и вы сами себе.

## Простое   ↔   Имитация Сложности   ↔   Сложное

Тогда и вы сможете варьировать сложность вашего решения как вы захотите.
Двигаясь в нужную сторону.

![41](Slides/Slide(41)Crop.png)

> Простое   ↔   Имитация Сложности   ↔   Сложное

## Ссылки

- [Rich Hickey, Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy/)

- [Vlad Balin, Software: Managing the Complexity](https://medium.com/@gaperton/software-managing-the-complexity-caff5c4964cf)

- [Keep It Simple Stupid (KISS)](http://principles-wiki.net/principles:keep_it_simple_stupid)

- [Основы теории надежности, Расчет показателей надежности невосстанавливаемых нерезервированных систем.](http://stellus.rgotups.ru/exec/learning_materials/%D0%9A%D0%B0%D1%84%D0%B5%D0%B4%D1%80%D0%B0%20'%D0%96.%D0%B4.%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,%20%D1%82%D0%B5%D0%BB%D0%B5%D0%BC-%D0%BA%D0%B0%20%D0%B8%20%D1%81%D0%B2%D1%8F%D0%B7%D1%8C'/%D0%9E%D0%A2%D0%9D%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1)/%D1%83%D1%87.%20%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5%20%E2%84%961%20%5b%D0%B4%D0%BE%D0%BF.%5d%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1)/%D1%83%D1%87.%20%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5%20%E2%84%961%20%5b%D0%B4%D0%BE%D0%BF.%5d%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1).pdf)

# DotNetRu

[DotNetRu](https://dotnet.ru/communities) — группа независимых сообществ .NET разработчиков со всей России. Мы объединяем людей вокруг .NET платформы, чтобы способствовать обмену опытом и знания. Проводим регулярные встречи, чтобы делиться новостями и лучшими практиками в разработке программных продуктов.

Мы стараемся объединить всех .NET разработчиков России, стать тем метасообществом, где можно посмотреть видео всех докладов, почитать новости, поделиться своими знаниями или мнением на ту или иную тему. [В 2018 году нас было 4 города](https://habr.com/ru/company/jugru/blog/334476/), а в 2020 уже 13! Это настоящее объединение русскоговоряющих .NET сообществ.

[DotNetRu](https://vk.com/dotnetru) ставит перед собой следующие цели:

- собираться вместе, знакомиться, обсуждать новости, делиться проблемами и искать решения;
- приглашать самых лучших докладчиков, настоящих профессионалов и уникальных авторов;
- находить и подготавливать новых спикеров для крупнейших российских конференций;
- создать и поддерживать [качественную коллекцию видео-лекций](https://www.youtube.com/DotNetRu).

Мы в телеграмме: [новостной канал DotNetRu](https://t.me/DotNetRu) и [обсуждение насущных вопросов DotNetRuChat](https://t.me/DotNetRuChat).

Если вы хотите организовать .NET сообщество в вашем городе, [свяжитесь с нами](mailto:hi@DotNet.Ru). У нас богатый опыт организации встреч, тренировки докладчиков, общения со спонсорами и мы всегда рады новым инициативам. Пишите по любым вопросам и предложениям. Мы сами перенаправим ваше послание нужному адресату. Присоединяйтесь, вместе — мы сила!





