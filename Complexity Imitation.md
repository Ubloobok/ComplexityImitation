# Имитация Сложности

Простое не требует Сложного.

Программисты много говорят про сложность решений. Мы можем часами размышлять о правильных шаблонах, красивых абстракциях и цепочках зависимостей. Но давайте поговорим открыто, всегда ли сложность обусловлена решаемой проблемой? Не оказываемся ли мы в плену наших стереотипов и убеждений?

![sdf](Slides/Slide(8).PNG)

Доброго дня. Меня зовут Никита Данилов, я ведущий .NET разработчик (aka Software Engineer). В 2018 году я выступал на встрече SarDotNet с докладом, расшифровкой которого хочу поделиться (отчасти вольной, для более точной передачи мыслей).

***О себе***

Начинал как WPF .NET разработчик, сейчас заядлый Back-end разработчиком, веб-сервисы, базы данных, очереди, микросервисы и прочая вкуснотища. Интересуюсь как техническими нюансами .NET платформы, так и философскими аспектами ремесла программиста. На момент выступления заканчивал аспирантуру (в 2019 году закончил) и четвёртый год преподавал в вузе, что вызвало у меня определенную профессиональную деформацию.

## Вступление

Сегодня мы поговорим об имитации. Вынужден предупредить заранее – этот . Всё что вы сейчас увидите – мысли на обдумывание, а не точные советы.

## Сложное

Программисты много говорят про сложность решений. Мы можем часами размышлять о правильных шаблонах и красивых абстракциях. Как сделать еще гибче, еще круче, еще сложнее. Как усложнить. Обычно мы двигаемся от простого к сложному.

![sdf](Slides/Slide(3)Crop.PNG)

На доклад меня сподвигло именно это, мы мало говорим о простом. По крайней мере в моём окружении например мало разговоров об этом. Хоть и есть книги, статьи разные восхваляющие простые решения, чаще мы смотрит на сложное. Поэтому, давайте сегодня пройдемся от сложного к простому, через таинственную имитацию сложности.

![sdf](Slides/Slide(4)Crop.PNG)

Сразу предупрежу, что доклад может быть опасен для неокрепших умов и тут будет в основном много мыслей и намеков на то, о чем у вас должны появиться мысли. Я предлагаю всем вместе подумать, почему мы так мало говорим про простые решения и много концентрируемся на сложных. Давайте начнем обсуждать это.

### Малое и Большое, Простое и ... Хаос

Если говорить про сложное и сложность, то вроде много всего написано. Размышляя про код, модули, архитектуру. Интуитивно мы понимаем что такое маленькое и большое. Можем примерно отличить нечто простое как кирпич и условно понимаем когда творится некий хаос с лапшой. Если присмотреться, все эти термины тесно связаны с понятием сложности.

![sdf](Slides/Slide(5)Crop.PNG)

Попробуйте подумать и вспомнить – что такое сложность? Какие существуют критерии и определения сложности кода или архтитектуры. Для вас именно какие критерии кода или архитектуры означают сложность.

![sdf](Slides/Slide(6)Crop.PNG)

И так, отлично. Обозначений сложности правда много, она многогранна.
Понятно, что проектов с нулевой сложностью не бывает.
Мы еще вернемся к тому что записали.

* CBO (Coupling Between Classes)
* NOC (Number of Children)
* DIT (Depth of Inheritance)
* WMC (Weighted Methods per Class)
LCOM (Lack of Cohesion of Methods)
* Complexity: Cyclomatic, Data, Decisional, Data Flow

Если так посмотреть, наш мир и правда много в чем непрост. Как нам кажется.

![sdf](Slides/Slide(8).PNG)

Выписал навскидку слова, которые крутились в голове – ГОСТ стандарты, финансы, физика и т.д.
Справедливости ради, мы зачастую сами явно не упрощаем. Например, если мы вспомним какие шаблоны работы с Git мы можем придумать, мы явно не упрощаем.
С другой стороны, ведь сложно далеко не всё. Есть примеры когда один небольшой VBA скрипт в екселе, решал проблемы целого завода. Что вроде бы огромная сложная структура. Тяжело назвать завод простым.
Но нагоняется армия аналитиков, менеджеров, приносится Git, стратегии бранчевания, фреймворки, Blue-Green развертывание. И вот уже вы сидите с 40 серверами и пытаетесь понять почему оно не работает. Решая примерно то же, что решал VBA скрипт.

## Имитация Сложности

Несмотря на то, что в этом мире существуют явно сложные задачи, тем не менее есть такая категория решений, которые строятся сложнее чем они могли бы быть построены. Банально, вы пишете больше кода чем вам необходимо чтобы решить эту проблему. Именно где то здесь кроется имитация, большая серая зона, можно сказать промежуточная.

![sdf](Slides/Slide(9)Crop.PNG)

Разрабатываемое решение попавшее в эту зону уже нельзя считать простым.
Но и сложность пока выглядит сомнительно либо неуместно, либо недостаточно.

На мой взгляд, здесь отлично подходит слово «имитация» для обозначения, что означает подражание, воспроизведение.

* imitari (праиндоевр.) — подражать, воспроизводить.
* imitatio (лат.) — подражание.

Когда мы имитируем сложность, у нас её еще нет, но мы решили попробовать подражать ей. Позвольте объяснить точнее.

Давайте рассмотрим на условном примере.
Вам передают приложение, разработанное кем то иным, допустим REST API .
Вы открываете и видите 7 проектов: контракты, ядро, данные, веб-часть, фасады.
Богато выглядит, думаете вы, наверняка оно что-то важное решает.

![sdf](Slides/Slide(11)Crop.PNG)

Открываете первый проект. Там 2 папки. 2 интерфейса на фасады. Какой-то интерфейс видимо указывающий что сущность можно валидировать. Хотя сущностей всего 2 и вроде и так логично что их можно валидировать.

Открываете фасады, думаете может там хитрость закопана. Но нет, там всего два фасада, по одной реализации, нет переключения например с одной базы данных на другую. Закрадываются сомнения, а всё ли так богато на самом деле.

Постепенно вы знакомитесь с проектом, открываете Web, думается там вся соль! Но нет, там только один контроллер и стандартная конфигурация.

![sdf](Slides/Slide(15)Crop.PNG)

Пример несколько гипербализирован, но тем не менее, ситуация многим может быть знакома.
Вопрос: На ваш взгляд, обоснована ли здесь такая разбивка на проекты? Нужна ли здесь такая организация кода?

Универсальный ответ - "зависит", это зависит от контекста, чего хотели достичь.
Возможно это всё будет ещё расширяться, возможно нет, но если вдруг будет, приложение готово к расширению.
Я не говорю что организация кода это плохо.
Но вроде всё это упаковывается в 2 проект и несколько файлов, на первое время.
Давайте посмотрим другой пример.

Вы создаете новое приложение, допустим, REST API.
Решили начать всё с контроллера. Вы описали контроллер, описали сущности контракта.

![sdf](Slides/Slide(16)Crop.PNG)

И вроде маловато. Надо еще как то модульные тесты написать наверное, хорошо бы покрыть модульными тестами - создаете аксессор (и/или: репозиторий, UnitOfWork, DB-контекст, ...).

![sdf](Slides/Slide(17)Crop.PNG)

Потом идете на кухню попить чайку, открываете книгу про шаблоны проектирования, посещаете конференцию где вам рассказывают еще 3 истории успеха внедрения DDD и CQRS. То есть вы где то что то узнаете, не успеваете оглянуться, вжух – кембрийский взрыв. В приложении появляются горы останков всех известных слов для выражения зависимостей:

![sdf](Slides/Slide(18)Crop.PNG)

Контракты, фасады, прокси, процессоры и т.д. и т.п.
Я знаком с приложениями где больше слов, а делают они пока очень мало чего.

> Справедливости ради, спустя 2 года эти приложения научились делать значительно больше и превратились в серьезные системы. Правда, некоторые зависимости так никогда и не были использованы, а некоторые раздробились на множество новых.

**Вопрос**: Насколько оно обосновано?

Опять таки, возможно, всё здесь и как надо. Возможно усложнили код предполагая будущие задачи.
В теории правильно выстроенная архитектура и не должна позволять сделать неправильно.
Всё зависит от контекста и наших целей.
Но вот есть определенная грань когда по идее эта сложность еще не нужна и в этот момент начинается имитация сложности - будущей или *вымышленной*.

![sdf](Slides/Slide(19)Crop.PNG)

Имитация сложности – подражание сложности.Подсмотренной в книгах или на конференциях.

Зачем мы имитируем?

* Чтобы выглядело круто, посложнее, солиднее, богаче, изучить новый подход.
* Иногда мы пробуем сделать посложнее чтобы изучить новый подход.
* Показать что мы это умеем.
* Попробовать.
* Вдруг диплом не примут.
* Есть еще такое слово "Гибкость", вот чтобы было гибко, конфигурируемо. Мы же сейчас всё сделаем так, что потом поменяем два контракта и всё будет работать как раньше.
* Слабая связанность.
* Избежать технического долга.

Причины могут быть разные, я не берусь сейчас разделять на хорошие и плохие. Главное принять, что есть ситуации, когда мы имитируем. Например, мне знакомы ситуации, когда люди привносили сложность, потому что им было стыдно показать простое решение. Они выходили на кухню, там все рассказывали про сложные паттерны, и они думали "Как же я свои 2 класса покажу", это же всё не по книгам.

Причин много, но важно что мы часто их не разделяем. У нас есть универсальные слова типа "гибко", "на будущее.

Мне доводилось самому делать такие приложения как показал на предыдущих слайдах – сразу всё по полочкам, с кучей слов. Потом вернулся через 3 года и выкинул много лишнего, что так и не пригодилось.

Причин усложнить всегда много. Важно трезво и честно оценивать зачем мы усложняем. Ибо зачастую какая главная причина? Сделаем погибче, еще гибче. Многое прячем под этим словом.

Серая область имитации сложности довольно большая и относительная.
Но чтобы её лучше понять, почему она есть – надо сначала поговорить про простое и сравнить потом с простым.

## Простое

Раз есть критерии сложности, то с другой стороны будет нечто обратное. Мы часто забываем о преимуществах которые нам может дать простое решение.

![sdf](Slides/Slide(21)Crop.PNG)

Есть такой принцип [KISS](http://principles-wiki.net/principles:keep_it_simple_stupid) (Keep it Simple S.).
Он четко сформулирован, про него достаточно много написано. Вспомним, что нам в принципе дает простое решение?

![sdf](Slides/Slide(22)Crop.PNG)

### 1. Проще → Быстрее Разработка

Во-первых, простое быстрее реализовать.
Санки, машина, ракета - всё из этого решает задачу – добраться из пункта А в пункт Б.

![sdf](Slides/Slide(23)Crop.PNG)

Безусловно, для полета в космос санки не сгодятся.
При этом, санки сделать быстрее чем космический корабль.
Если мы понимаем, что нам надо лишь съехать с горки, то быть может и куска линолеума хватит.
В этом случае даже санки будут являться имитацией сложности.
Вот мы захотели на более вычурных санках съехать, хотя линолеум прекрасно справился бы.
Еще и деньги и время остались бы.

## 1. Проще → Быстрее Разработка

Другой пример это когда вам надо доплыть.

![sdf](Slides/Slide(24)Crop.PNG)

Летом чтобы доплыть до островка, вы не всегда строите себе личный катер, иногда хватает подручных средств.
Иногда вы арендуете уже существующий катер, сложность при этом перекладывается.
В этом случае для нас проще будет означать быстрее разработка.

## 2. Проще → Надежнее Работа

Во-вторых, проще означает надежнее работа.
Смотрите, мы назвали много критериев сложности.
Увеличение сложности так или иначе заставит нас написать больше кода.

Если мы входим в зону имитации сложности, мы начинаем добавлять код, вряд ли убавлять.

**Вопрос**: Какова вероятность ошибки или опечатки в строке кода? 1% или 0.1% или 0.01%?
Понятно что самые очевидные компилятор проверит.

Допустим мы уверены что вероятность ошибки в строке кода крайне мала и равна 0.01%.
Перемножая вероятности ошибки на большом приложении с 10 000 строк кода, получаем 100%, что там есть ошибка. Что-то здесь не так...

![sdf](Slides/Slide(26)Crop.PNG)

Причем исправление одной уменьшит вероятность лишь на одну сотую.
Хорошо, допустим мы пишем практически идеально.
Уменьшим вероятность еще на 2 знака, получим вероятность ошибки 1% на 10 000 строк кода.
Но потом вспоминаем что у нас минимум 100 взаимосвязей или разных зависимостей между классами.

![sdf](Slides/Slide(27)Crop.PNG)

Продолжать можно бесконечно.
"Больше последовательных звеньев - ниже надежность".
Сложность проверки превосходит количество строк кода в миллионы раз.
Поэтому, чем меньше кода в вашем решении, тем больше шанс что он будет работать надежно. Обычно.

## 3. Проще → Понятнее для Поддержки

Третий момент – понятность для поддержки. Снова посмотрим на критерии сложности.
Многие означают – чем сложнее, тем больше у вас будет методов, классов, абстракций.
Многие шаблоны придуманы чтобы сокрыть сложность за неким интерфейсом.
Даже если они звучат лаконично, в реализации это может означать десятки классов.

То есть сложность зачастую приносит новые абстракции.

* Абстракции облегчают/упрощают восприятие при моделировании.
* Абстракции скрывают Сложность. 

Вроде чтобы абстрагироваться от деталей.
Здесь мы спрятали за фасадом, здесь укрыли в репозиторий, и кажется что сложности у нас нет.
Начав вводить все эти вещи заранее, мы что делаем? Имитируем будущую сложность.

![sdf](Slides/Slide(18)Crop.PNG)

Проходит время и вы оказываетесь в роли знаменитой Даши. Где-то в глубине приложения что-то упало и вы начинаете копать.

![sdf](Slides/Slide(30)Crop.PNG)

Начинаем смотреть на наши зависимости приправленные любимым контейнером для внедрения.
Что-то там делается, вызывается менеджер с разными параметрами.

    class Controller
    {
        Controller(IManager, ILogger, ISettings) { … }
    
        Load()
        {
            …
            var data = _manager.Load(...);
            …
        }
    }

Идем дальше.
Менеджер вроде тоже вполне прозрачный, зависимости какие-то.
Но параметры перекомпоновывает, поэтому надо разобраться как.
Разобрались, идём дальше.

    class Manager
    {
        Manager(IFacade, ILogger, IChecker, IWrapper) { … }
    
        Load()
        {
            …
            var data = _facade.Load(...);
            …
        }
    }

Открываем фасад, там еще порция зависимостей.
Перегруппировка параметров и вызов дальше аксессора.

    class Facade
    {
        Facade(IAccessor, ILogger, IPermission, IPhone) { … }
    
        Load()
        {
            …
            var data = _accessor.Load(...);
            …
        }
    }

Открываем аксессор, нет зависимостей – ура!

    class Accessor
    {
        Accessor() { }
    
        Load(...)
        {
            NLog.Instance.Write(…);
            var context = new DbContext("connectionString");
            var data = context.Entities.ToList();
        }
    }

Но видимо человек кто писал аксессор на этом уровне, уже просто устал разбираться.
Взял любимый логгер, указал хардкодом строку подключения и понеслась.
Теоретически, архитектура не должно позволять делать такое.
Но кто запретит человеку выстрелить себе в ногу?
Возможно на код-ревью потом отловим. А может и нет, переименуется строка подключения и всё полетит.

Этот пример о том, что вот лично я стал уставать от обилия абстракций.
Здесь десяток абстракций запомни, здесь десяток, и вроде недолго разбираться, но время тратится.
Грустно, хочется проблему решать, а не заучивать плоды чьей то фантазии.

### Так почему не делать всё Просто?

Итого, простота ведет к Скорости, к Надежности, к Поддерживаемости. Казалось бы,

_"Обалдеть, дайте две!_" (с)

Кажется, всё замечательно, давайте делать всё максимально просто.
Чего я вообще тут про имитацию распинаюсь.

![sdf](Slides/Slide(36)Crop.PNG)

Разумеется здесь возникает знаменитая тройка: лебедь, рак и щука... т.е. скорость, надежность и поддерживаемость. 

![sdf](Slides/Slide(37).PNG)

([источник](http://audiohrestomatiya.ru/competitions2/?page=219&now_sort=name_d&now_filter_name=name&now_filter_val=), автор: Анна Тимакова, Город: Москва, возраст: 7 лет)

Да еще и решаемая задача каждый раз особая.
Для одной допустимо простое решение, для другой придется усложнять.
К сожалению реально полноценно совместить лишь 2 аспекта, а 3й обязательно будет страдать.
Примерно как CAP теорема, только про другое (очень уж людям нравится тройственное ограничение).
Нам придется делать выбор, а выбор обусловлен целями, как мы помним.
Иногда топорное решение даст проблемы при поддержке.
А иногда наоборот позволит быстрее переписать если что.

## Кто виноват? Что делать?

К чему я это всё. Про что я предлагаю подумать. 

Я не призываю вообще не делать сложность
Сложность бывает оправдана, да и часто она оправдана.
Всё-таки мы тут проблемы Бизнеса решаем, а не просто лямбды пишем.
Но если мы всегда будем строить только космические корабли, то саночек у нас не останется.

Прежде всего я призываю быть честными по отношению к себе, к коллегам и решаемой задаче.

во-первых – упрощать саму постановку проблемы.
До начала обдумывания и проектирования.
Возможно, проблема решается большими красными буквами на странице, вместо отката распределенной транзакции.
Только упростив проблему, уже решать хотим мы усложнять решение или нет.

> "Всё следует упрощать до тех пор, пока это возможно, но не более того" (с) Альберт Эйнштейн

И только тогда, делая решение – решать желаете ли вы привнести сложность.
Если вы знаете что нужен супер гибкий механизм – ОК, вы эксперт, делайте.
Если вы хотите именно здесь опробовать новый подход, и знаете что он не заставит никого страдать – ОК, пробуйте.
Но только помните о том, что вам дает простое решение.
Вообще давайте чаще задумываться о простом.
Тогда и лучше станем понимать когда стоит привносить сложность.
Не оправдывая всё словом «гибкость».
Потом вам и другие скажут спасибо, и вы сами себе.

## Простое   ↔   Имитация Сложности   ↔   Сложное

Тогда и вы сможете варьировать сложность вашего решения как вы захотите.
Двигаясь в нужную сторону.

![sdf](Slides/Slide(41)Crop.PNG)

## Ссылки

[Software: Managing the Complexity](https://medium.com/@gaperton/software-managing-the-complexity-caff5c4964cf)

[Keep It Simple Stupid (KISS)](http://principles-wiki.net/principles:keep_it_simple_stupid)

[Основы теории надежности ,Расчет показателей надежности невосстанавливаемых нерезервированных систем.](http://stellus.rgotups.ru/exec/learning_materials/%D0%9A%D0%B0%D1%84%D0%B5%D0%B4%D1%80%D0%B0%20'%D0%96.%D0%B4.%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,%20%D1%82%D0%B5%D0%BB%D0%B5%D0%BC-%D0%BA%D0%B0%20%D0%B8%20%D1%81%D0%B2%D1%8F%D0%B7%D1%8C'/%D0%9E%D0%A2%D0%9D%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1)/%D1%83%D1%87.%20%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5%20%E2%84%961%20%5b%D0%B4%D0%BE%D0%BF.%5d%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1)/%D1%83%D1%87.%20%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5%20%E2%84%961%20%5b%D0%B4%D0%BE%D0%BF.%5d%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1).pdf)
