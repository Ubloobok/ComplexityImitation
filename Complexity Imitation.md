# Имитация Сложности — Антиномия Простого и Сложного

Простое не требует Сложности.

Программисты много говорят про сложность решений. Мы можем часами размышлять о правильных шаблонах, красивых абстракциях и цепочках зависимостей. Однако давайте поговорим открыто, всегда ли сложность обусловлена решаемой проблемой? Не оказываемся ли мы в плену наших стереотипов и убеждений?

![8](Slides/Slide(8).PNG)

<cut />

Доброго дня. Меня зовут Никита Данилов, я ведущий .NET разработчик. В 2018 году я выступал на встрече [SarDotNet](https://vk.com/sardotnet) с [докладом "Имитация сложности"](https://www.youtube.com/watch?v=z6yxXJxmst8) (Саратовское сообщество всероссийского [DotNetRu](https://vk.com/dotnetru)), расшифровкой которого хочу поделиться (отчасти вольной, для более точной передачи мыслей).

***О себе***

Начинал как WPF .NET разработчик, сейчас заядлый Back-end разработчик, веб-сервисы, базы данных, очереди, микросервисы и всё такое. Интересуюсь как техническими нюансами .NET платформы, так и философскими аспектами ремесла программиста. На момент выступления заканчивал аспирантуру (в 2019 году закончил) и четвёртый год преподавал в вузе, что вызвало у меня определенную ментальную и профессиональную деформацию.

## Вступление

Сегодня мы поговорим об имитации. Вынужден предупредить заранее, всё что вы сейчас увидите и услышите – мысли на обдумывание, а не точные советы.

## Сложное

Программисты много говорят про сложность решений. Мы можем часами размышлять о правильных шаблонах и красивых абстракциях. Как сделать еще гибче, еще круче, еще сложнее. Как усложнить. Обычно мы двигаемся от простого к сложному.

![3](Slides/Slide(3)Crop.png)

> Простое → **Сложное**

На доклад меня сподвигло именно то, что мы мало говорим о простом. По крайней мере в моём окружении мало разговоров об этом. Существуют статьи восхваляющие простые решения, но таковых довольно мало и чаще мы говорим о сложном. Давайте сегодня пройдемся от сложного к простому, через таинственную имитацию сложности. Предлагаю всем вместе подумать, почему мы так мало говорим про простые решения и много концентрируемся на сложных.

![4](Slides/Slide(4)Crop.png)

> Простое ← Имитация Сложности ← **Сложное**

### Малое и Большое, Простое и ... Хаос

Если говорить про сложное и сложность, то вроде много всего написано. Размышляя про код, модули или архитектуру, мы интуитивно понимаем что такое маленькое и большое. Можем примерно отличить нечто простое (как кирпич) и условно понимаем когда творится некий хаос (с лапшой). Если присмотреться, все эти термины тесно связаны с понятием сложности.

![5](Slides/Slide(5)Crop.png)

Попробуйте подумать, повспоминать и ответить на следующие вопросы:

- Что такое сложность?
- Какие вообще существуют критерии и определения сложности кода или архтитектуры?
- Какие критерии кода или архитектуры означают сложность именно для вас?

![6](Slides/Slide(6)Crop.png)

Обозначений сложности правда много, она многогранна, и разумеется проектов с нулевой сложностью не бывает, перечислим лишь наиболее известные:

- Метрики размера программ:
  - SLOC (Source Lines of Code), анализ количества строк кода;
  - Метрика Холстеда, анализ числа операторов и операндов программы;
- Метрики сложности потока управления:
  - Метрика Маккейба, или Цикломатическая сложность (англ. Cyclomatic);
  - Метрика Майерса (расширение метрики Маккейба);
  - Метрика Джилба, насыщенность выражениями типа IF-THEN-ELSE;
- Метрики сложности потока данных:
  - Метрика Чепина и её модификации;
  - Метрика Спена;
- Метрики специфичные для объектно-ориентированного программирования:
  - NOC (Number of Children), анализ количества непосредственных потомков;
  - DIT (Depth of Inheritance), анализ глубины дерева наследования;
  - WMC (Weighted Methods per Class), анализ суммарной сложности всех методов класса;
  - CBO (Coupling Between Classes);
  - LCOM (Lack of Cohesion of Methods);
- и т.д. и многие другие.

К сожалению, зачастую люди находят информацию лишь про SLOC, где обнаруживают критику, что метрика устарела с развитием языков, и на этом изучение теории сложности программного обеспечения завершается.

Словари определяют, что само слово «сложный» является антонимом к слову «простой» и имеет несколько устоявшихся значений:

- состоящий из нескольких частей, элементов;
- многообразный по составу входящих частей, отношений, связей;
- затейливый, замысловатый по строению, форме;
- представляющий затруднения для понимания, решения, осуществления и т.п.

Если так посмотреть, наш мир и правда много в чем сложен. Как нам кажется.

![8](Slides/Slide(8).PNG)

Выписал навскидку слова, которые крутились в голове – ГОСТ, финансы, LESS, физика, Docker и т.д.
Справедливости ради, мы зачастую сами явно не упрощаем. Например, если мы вспомним какие шаблоны работы с Git мы можем придумать, мы явно не упрощаем.
С другой стороны, ведь далеко не всё является сложным. Есть примеры когда один небольшой VBA скрипт в екселе решал проблемы целого завода. Что вроде бы огромная сложная структура. Тяжело назвать завод простым.
Но нагоняется бригада аналитиков, менеджеров, приносится Git, стратегии бранчевания, фреймворки, Blue-Green развертывание. И вот уже вы сидите с 40 серверами и пытаетесь понять почему оно не работает. Решая примерно то же, что решал VBA скрипт.

## Имитация Сложности

Несмотря на то, что в этом мире существуют явно сложные задачи, тем не менее есть особая категория решений, которые строятся сложнее чем они могли бы быть построены. Например, вы пишете больше кода чем вам необходимо чтобы решить эту проблему. Именно где то здесь кроется имитация, можно сказать промежуточная большая серая зона.

![9](Slides/Slide(9)Crop.png)

Разрабатываемое решение попавшее в эту зону уже нельзя считать простым, однако и сложность пока выглядит сомнительно либо неуместно.

На мой взгляд, для описания подобной ситуации отлично подходит слово «имитация» имеющее древние корни:

- imitari (праиндоевр.) — подражать, воспроизводить.
- imitatio (лат.) — подражание.

Когда мы имитируем сложность, у нас её еще нет, но мы решили попробовать подражать ей. Позвольте объяснить точнее.

Рассмотрим на условном примере.

Вам передают приложение, разработанное кем то иным, допустим REST API .
Вы открываете и видите 7 проектов: контракты, ядро, данные, веб-часть, фасады.
Богато выглядит, думаете вы, наверняка оно что-то важное решает.

![11](Slides/Slide(11)Crop.png)

Открываете первый проект. Там 2 папки. 2 интерфейса на фасады. Какой-то интерфейс видимо указывающий что сущность можно валидировать. Хотя сущностей всего 2 и вроде и так логично что их можно валидировать.

Открываете фасады, думаете может там хитрость закопана. Но нет, там всего два фасада, по одной реализации, нет переключения например с одной базы данных на другую. Закрадываются сомнения, а всё ли так богато на самом деле.

Постепенно вы знакомитесь с проектом, открываете Web (думается там вся соль!), но нет, там только один контроллер и стандартная конфигурация.

![15](Slides/Slide(15)Crop.png)

Пример несколько гипербализирован, но тем не менее, ситуация многим может быть знакома.

*Вопрос:* На ваш взгляд, обоснована ли здесь такая разбивка на проекты? Нужна ли здесь такая организация кода?

Универсальный ответ - "зависит", это зависит от контекста, чего хотели достичь.
Возможно это всё будет ещё расширяться, возможно нет, но если вдруг будет, приложение готово к расширению.
Я не говорю что организация кода это плохо.
Но вроде всё это упаковывается в 2 проекта и несколько файлов, на первое время.

Рассмотрим другой пример.

Вы создаете новое приложение, допустим, REST API.
Решили начать всё с контроллера. Вы описали контроллер, описали сущности контракта.

![16](Slides/Slide(16)Crop.png)

И ощущаете, вроде маловато. Надо еще как то модульные тесты написать наверное - создаете аксессор (и/или: репозиторий, UnitOfWork, DB-контекст, ...).

![17](Slides/Slide(17)Crop.png)

Потом идете на кухню попить чайку, открываете книгу про шаблоны проектирования, посещаете конференцию где вам рассказывают еще 3 истории успеха внедрения DDD и CQRS. То есть вы где-то что-то узнаете, не успеваете оглянуться, вжух – кембрийский взрыв. В приложении появляются останки всех известных слов для выражения зависимостей:

![18](Slides/Slide(18)Crop.png)

Контракты, фасады, прокси, процессоры и т.д. и т.п.
Я знаком с приложениями где больше слов, а делают они пока очень мало чего.

> Справедливости ради, спустя 2 года эти приложения научились делать значительно больше и превратились в серьезные системы. Правда, некоторые зависимости так никогда и не были использованы, а некоторые раздробились на множество новых.

**Вопрос**: Насколько оно обосновано?

Опять таки, возможно, всё здесь и как надо. Возможно усложнили код предполагая будущие задачи.
В теории правильно выстроенная архитектура и не должна позволять сделать неправильно.
Всё зависит от контекста и наших целей.
Но вот есть определенная грань когда по идее эта сложность еще не нужна и в этот момент начинается имитация сложности - будущей или *вымышленной*.

![19](Slides/Slide(19)Crop.png)

Имитация сложности – подражание сложности. Подсмотренной в книгах или на конференциях.

Попробуйте подумать, зачем мы имитируем?

* Крутизна, чтобы выглядело круто, посложнее, солиднее, богаче, изучить новый подход.
* Изучение, иногда мы пробуем сделать посложнее чтобы изучить новый подход.
* Демонстрация, показать что мы это умеем.
* Вдохновение, попробовать нечто новое и крышесносящее.
* Опасения, чтобы приняли диплом.
* Гибкость, волшебное слово "гибкость", чтобы было гибко, конфигурируемо, мы же сейчас всё сделаем так, что потом поменяем два контракта и всё будет работать как раньше.
* Связанность, стараемся добиться слабой связанности модулей.
* Избежать технического долга.

Причины могут быть разные, я не берусь сейчас разделять на хорошие и плохие. Главное принять, что есть ситуации, когда мы имитируем. Например, мне знакомы ситуации, когда люди привносили сложность, потому что им было стыдно показать простое решение. Они выходили на кухню, там все рассказывали про сложные паттерны, и они думали "Как же я свои 2 класса покажу", это же всё не по книгам.

Причин усложнить всегда много, но зачастую мы их не различаем. Важно **рационально** и **честно** оценивать зачем мы усложняем. Ибо зачастую какая главная причина? Сделаем погибче, еще гибче, на будущее. Многое прячем под этими общими словами.

Мне доводилось самому делать такие приложения как показал на предыдущих слайдах – сразу всё по полочкам, с кучей слов. Потом вернулся через 3 года и выкинул много лишнего, что так и не пригодилось.

Серая область имитации сложности довольно большая и относительная.
Но чтобы её лучше понять, почему она есть – надо сначала поговорить про простое и сравнить потом с простым.

## Простое

Раз есть критерии сложности, то с другой стороны будет нечто обратное. Мы часто забываем о преимуществах которые нам может дать простое решение.

![21](Slides/Slide(21)Crop.png)

Есть такой принцип [KISS](http://principles-wiki.net/principles:keep_it_simple_stupid) (Keep it Simple S.).
Он четко сформулирован, про него достаточно много написано. Вспомним, что нам в принципе дает простое решение?

![22](Slides/Slide(22)Crop.png)

### 1. Проще → Быстрее Разработка

Во-первых, простое быстрее реализовать.
Санки, машина, ракета - всё из этого решает задачу – добраться из пункта А в пункт Б.

![23](Slides/Slide(23)Crop.png)

Безусловно, для полета в космос санки не сгодятся.
При этом, санки сделать быстрее чем космический корабль.
Если мы понимаем, что нам надо лишь съехать с горки, то быть может и куска линолеума хватит.
В этом случае даже санки будут являться имитацией сложности.
Вот мы захотели на более вычурных санках съехать, хотя линолеум прекрасно справился бы.
Еще и деньги и время остались бы.

## 1. Проще → Быстрее Разработка

Другой пример это когда вам надо доплыть.

![24](Slides/Slide(24)Crop.png)

Летом чтобы доплыть до островка, вы не всегда строите себе личный катер, иногда хватает подручных средств.
Иногда вы арендуете уже существующий катер, сложность при этом перекладывается.
В этом случае для нас проще будет означать быстрее разработка.

## 2. Проще → Надежнее Работа

Во-вторых, проще означает надежнее работа.
Смотрите, мы назвали много критериев сложности.
Увеличение сложности так или иначе заставит нас написать больше кода.

Если мы входим в зону имитации сложности, мы начинаем добавлять код, вряд ли убавлять.

**Вопрос**: Какова вероятность ошибки или опечатки в строке кода? 1% или 0.1% или 0.01%?
Понятно что самые очевидные компилятор проверит.

Допустим мы уверены что вероятность ошибки в строке кода крайне мала и равна 0.01%.
Перемножая вероятности ошибки на большом приложении с 10 000 строк кода, получаем 100%, что там есть ошибка. Что-то здесь не так...

![26](Slides/Slide(26)Crop.png)

Причем, исправление одной ошибки уменьшит вероятность следующей лишь на одну сотую.
Допустим мы пишем практически идеально.
Уменьшим вероятность еще на 2 знака, получим вероятность ошибки 1% на 10 000 строк кода.
Но потом вспоминаем что у нас минимум 100 взаимосвязей или разных зависимостей между классами.

![27](Slides/Slide(27)Crop.png)

Продолжать можно бесконечно.
"Больше последовательных звеньев - ниже надежность".
Сложность проверки превосходит количество строк кода в миллионы раз.
Поэтому, чем меньше кода в вашем решении, тем больше шанс что он будет работать надежно. Обычно.

## 3. Проще → Понятнее для Поддержки

Третий момент – понятность для поддержки. Снова посмотрим на критерии сложности.
Многие означают – чем сложнее, тем больше у вас будет методов, классов, абстракций.
Многие шаблоны придуманы чтобы сокрыть сложность за неким интерфейсом.
Даже если они звучат лаконично, в реализации это может означать десятки классов.

То есть сложность зачастую приносит новые абстракции.

* Абстракции облегчают/упрощают восприятие при моделировании.
* Абстракции скрывают Сложность. 

Вроде чтобы абстрагироваться от деталей.
Здесь мы спрятали за фасадом, здесь укрыли в репозиторий, и кажется что сложности у нас нет.
Начав вводить все эти вещи заранее, мы что делаем? Имитируем будущую сложность.

![18](Slides/Slide(18)Crop.png)

Проходит время и вы оказываетесь в роли знаменитой Даши. Где-то в глубине приложения что-то упало и вы начинаете копать.

![30](Slides/Slide(30)Crop.PNG)

Начинаем смотреть на наши зависимости приправленные любимым контейнером для внедрения.
Что-то там делается, вызывается менеджер с разными параметрами.

    class Controller
    {
        Controller(IManager, ILogger, ISettings) { … }
    
        Load()
        {
            …
            var data = _manager.Load(...);
            …
        }
    }

Идем дальше.
Менеджер вроде тоже вполне прозрачный, зависимости какие-то.
Но параметры перекомпоновывает, поэтому надо разобраться как.
Разобрались, идём дальше.

    class Manager
    {
        Manager(IFacade, ILogger, IChecker, IWrapper) { … }
    
        Load()
        {
            …
            var data = _facade.Load(...);
            …
        }
    }

Открываем фасад, там еще порция зависимостей.
Перегруппировка параметров и вызов дальше аксессора.

    class Facade
    {
        Facade(IAccessor, ILogger, IPermission, IPhone) { … }
    
        Load()
        {
            …
            var data = _accessor.Load(...);
            …
        }
    }

Открываем аксессор, нет зависимостей – ура!

    class Accessor
    {
        Accessor() { }
    
        Load(...)
        {
            NLog.Instance.Write(…);
            var context = new DbContext("connectionString");
            var data = context.Entities.ToList();
        }
    }

Но видимо человек, кто писал аксессор на этом уровне, уже просто устал разбираться.
Взял любимый логгер, указал хардкодом строку подключения и понеслась.
Теоретически, архитектура не должна позволять делать такое.
Но кто запретит человеку выстрелить себе в ногу?
Возможно на код-ревью потом отловим. А может и нет, переименуется строка подключения и всё полетит.

Этот пример о том, что вот лично я стал уставать от обилия абстракций.
Здесь десяток абстракций запомни, здесь десяток, и вроде недолго разбираться, но время тратится.
Грустно, хочется проблему решать, а не заучивать плоды чьей то фантазии.

### Так почему не делать всё Просто?

Итого, простота ведет к Скорости, к Надежности, к Поддерживаемости. Казалось бы,

_"Обалдеть, дайте две!_" (с)

Кажется, всё замечательно, давайте делать всё максимально просто.
Чего я вообще тут про имитацию распинаюсь.

![36](Slides/Slide(36)Crop.png)

Разумеется здесь возникает знаменитая тройка: лебедь, рак и щука... т.е. скорость, надежность и поддерживаемость. 

![37](Slides/Slide(37).PNG)

([источник](http://audiohrestomatiya.ru/competitions2/?page=219&now_sort=name_d&now_filter_name=name&now_filter_val=), автор: Анна Тимакова, Город: Москва, возраст: 7 лет)

Да еще и решаемая задача каждый раз особая.
Для одной допустимо простое решение, для другой придется усложнять.
К сожалению реально полноценно совместить лишь 2 аспекта, а 3й обязательно будет страдать.
Примерно как CAP теорема, только про другое (очень уж людям нравится тройственное ограничение).
Нам придется делать выбор, а выбор обусловлен целями, как мы помним.
Иногда топорное решение даст проблемы при поддержке.
А иногда наоборот позволит быстрее переписать если что.

## Кто виноват? Что делать?

К чему я это всё. Про что я предлагаю подумать. 

Я не призываю совсем избегать сложности, ведь она бывает оправдана, да и зачастую она оправдана.
Всё-таки мы тут проблемы Бизнеса решаем, а не просто лямбды пишем.
Но если мы всегда будем строить только космические корабли, то саночек у нас не останется.

Прежде всего я призываю быть честными по отношению к себе, к коллегам и решаемой задаче.

Во-первых – упрощать саму постановку проблемы.
До начала обдумывания и проектирования.
Возможно, проблема решается большими красными буквами на странице, вместо отката распределенной транзакции.
Только упростив проблему, уже решать хотим мы усложнять решение или нет.

> "Всё следует упрощать до тех пор, пока это возможно, но не более того" (с) Альберт Эйнштейн

И только тогда, делая решение – решать желаете ли вы привнести сложность.
Если вы знаете что нужен супер гибкий механизм – ОК, вы эксперт, делайте.
Если вы хотите именно здесь опробовать новый подход, и знаете что он не заставит никого страдать – ОК, пробуйте.
Но только помните о том, что вам дает простое решение.
Вообще давайте чаще задумываться о простом.
Тогда и лучше станем понимать когда стоит привносить сложность.
Не оправдывая всё словом «гибкость».
Потом вам и другие скажут спасибо, и вы сами себе.

## Простое   ↔   Имитация Сложности   ↔   Сложное

Тогда и вы сможете варьировать сложность вашего решения как вы захотите.
Двигаясь в нужную сторону.

![41](Slides/Slide(41)Crop.png)

## Ссылки

- [Rich Hickey, Simple Made Easy](https://www.infoq.com/presentations/Simple-Made-Easy/)

- [Vlad Balin, Software: Managing the Complexity](https://medium.com/@gaperton/software-managing-the-complexity-caff5c4964cf)

- [Keep It Simple Stupid (KISS)](http://principles-wiki.net/principles:keep_it_simple_stupid)

- [Основы теории надежности, Расчет показателей надежности невосстанавливаемых нерезервированных систем.](http://stellus.rgotups.ru/exec/learning_materials/%D0%9A%D0%B0%D1%84%D0%B5%D0%B4%D1%80%D0%B0%20'%D0%96.%D0%B4.%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0,%20%D1%82%D0%B5%D0%BB%D0%B5%D0%BC-%D0%BA%D0%B0%20%D0%B8%20%D1%81%D0%B2%D1%8F%D0%B7%D1%8C'/%D0%9E%D0%A2%D0%9D%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1)/%D1%83%D1%87.%20%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5%20%E2%84%961%20%5b%D0%B4%D0%BE%D0%BF.%5d%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1)/%D1%83%D1%87.%20%D0%BF%D0%BE%D1%81%D0%BE%D0%B1%D0%B8%D0%B5%20%E2%84%961%20%5b%D0%B4%D0%BE%D0%BF.%5d%20(4%20%D0%BA%D1%83%D1%80%D1%81%20%D0%90%D0%A2%D0%A1).pdf)

# DotNetRu

[DotNetRu](https://dotnet.ru/communities) — группа независимых сообществ .NET разработчиков со всей России. Мы объединяем людей вокруг .NET платформы, чтобы способствовать обмену опытом и знания. Проводим регулярные встречи, чтобы делиться новостями и лучшими практиками в разработке программных продуктов.

Мы стараемся объединить всех .NET разработчиков России, стать тем метасообществом, где можно посмотреть видео всех докладов, почитать новости, поделиться своими знаниями или мнением на ту или иную тему. [В 2018 году нас было 4 города](https://habr.com/ru/company/jugru/blog/334476/), а в 2020 уже 13! Это не просто новостной портал, это настоящее объединение русскоговоряющих .NET сообществ.

DotNetRu ставит перед собой следующие цели:

- собираться вместе, знакомиться, обсуждать новости, делиться проблемами и искать решения;
- приглашать самых лучших докладчиков, настоящих профессионалов и уникальных авторов;
- находить и подготавливать новых спикеров для крупнейших российских конференций;
- создать и поддерживать [качественную коллекцию видео-лекций](https://www.youtube.com/DotNetRu).

Если вы хотите организовать .NET сообщество в вашем городе, [свяжитесь с нами](mailto:hi@DotNet.Ru). У нас богатый опыт организации встреч, тренировки докладчиков, общения со спонсорами и мы всегда рады новым инициативам. Пишите по любым вопросам и предложениям. Мы сами перенаправим ваше послание нужному адресату. Присоединяйтесь, вместе — мы сила!

https://vk.com/dotnetru

https://t.me/DotNetRu

